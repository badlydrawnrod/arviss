# Player Movement in Very Angry Robots III

**1/9/21**

Today I made a start on writing code to move the player. That might sound like a simple thing to do, and that would be true if that's all there was to it. But the reality is that the game has more than just a player. It has other entities, such as enemy robots, the player's shots, and the enemies' shots. It has walls and doors. Many of these entities need to interact with each other. For example, we need to know if the player hit a wall or a door, or if the player was shot by a robot.

In other words, when we move the player then a number of things need to take place.

- We need to get input from a keyboard or gamepad.
- We need to update the player's position based on that input.
- We need to check if the player has hit a wall, or a door, or if the player has been hit by an enemy or their shots.
- We need to draw the player in its new position.

## Problem: How do we model entity state and behaviour?

What we choose to do for the player entity has implications for everything else, because the game is composed of multiple, interacting entities, each of which will operate in a similar but not identical manner.

**Many entities need to be checked for their next action**. This is true for the player and the robots, but it is not true for shots, as they're essentially fire and forget.

**Many entities need to change position**. This is true for the player, the robots, and the shots, but it is not true of walls and doors.

**Many entities need to check for collisions with other entities**. But again, this is not true for all entities, and some entities might not collide with each other. For example, the player probably doesn't collide with their own shots, otherwise it would be game over pretty quickly.

**Most entities need to be drawn on the screen**. But there are exceptions. An entity might be an area trigger that causes something to happen when the player enters it.

In other words, there are certainly large overlaps between different types of entity, but it isn't a one-size-fits all. So, how do we go about modelling this?

## Approach: Use an Entity Component System

I've chosen to implement this by hand-rolling what these days is usually called an [Entity Component System (ECS)](https://en.wikipedia.org/wiki/Entity_component_system). The ECS approach typically groups data by use rather than by ownership, often modelling entities as something approaching a [Structure of Arrays (SoA)](https://en.wikipedia.org/wiki/AoS_and_SoA#Structure_of_Arrays) rather than the more usual [Array of Structures (AoS)](https://en.wikipedia.org/wiki/AoS_and_SoA#Array_of_Structures).

I've picked the SoA approach largely because of the way that the game will operate on data [^1]. Take the movement system, for example. This system takes a position and applies a velocity to it, and it does this for every active entity that has a position and a velocity. With an AoS approach, the CPU would iterate through each item in the array, and end up populating the cache with not only the positions and velocities, but also with other fields from the struct that *won't* be used by the movement system. With an SoA approach, the CPU would iterate through the component that holds positions and velocities and nothing more, making a more efficient use of the cache.

## Alternatives Considered

There are many other ways of solving this problem. I came quite close to using a node system [such as the one used to great effect by Godot](https://docs.godotengine.org/en/stable/getting_started/step_by_step/scenes_and_nodes.html). This is very flexible, but can end up in pointer soup which isn't particularly cache friendly (there's a reason why friends don't let friends use linked lists) and I'm trying to save as much performance as possible for Arviss itself.

Then there's the traditional GameObject. This is probably the most object oriented of all of the approaches, but...

a) I'm writing in C.

b) again, it isn't particularly cache-friendly.

## Implementing OO in C

Finally, I'd like to point out that it is perfectly possible to write OO code in C, as many a COM programmer can attest. One approach is to mimic virtual functions by creating your own [vtables](https://en.wikipedia.org/wiki/Virtual_method_table), and even to go as far as to create objects that are layout compatible with C++ classes, assuming that you don't have a weird C++ compiler that puts the vtable at the end.

In C++ where you'd write this...

```cpp
Vector2 position = entity->GetPosition();
```

In C, with a C++ compatible vtable, you might write it like this...

```cpp
Vector2 position = entity->pvtbl->GetPosition(pEntity);
```
It's ugly as hell, and somewhat repetitive, but it works. And yes, before you correct me, I am aware that there are many other approaches to OO in C - I just happen to be reasonably familiar with this one.

[^1]: The SoA approach reminds me of programming games in assembly language as a teenager. When I learned C I was quite surprised to find that AoS was so dominant.
